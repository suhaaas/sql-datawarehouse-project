--bronze layer before cleaning


select *
from bronze.crm_cust_info

-- check for nulls or duplicates in primary key

select cst_id,count(*)
from bronze.crm_cust_info
group by cst_id
having count(*)>1 or cst_id is null

select *
from bronze.crm_cust_info
where cst_id = 29466

-- rank values based on create date and choose highest one- using window function

select *,
row_number() over (partition by cst_id order by cst_create_date desc) as flag_last
from bronze.crm_cust_info

select *
from(
select *,
row_number() over (partition by cst_id order by cst_create_date desc) as flag_last
from bronze.crm_cust_info 
)t where flag_last = 1

-- quality checks - check for unwanted spaces in string values
select cst_lastname
from bronze.crm_cust_info
where cst_lastname != trim(cst_lastname)

select cst_gndr
from bronze.crm_cust_info
where cst_gndr != trim(cst_gndr)


-- data standardization and consistency
select distinct cst_gndr
from bronze.crm_cust_info

-- in this project, we aim to store clear and meaninful values rather than using abbreviations terms
-- missing values with na

--bronze layer transforming to silver layer
--doing checks

-- crm_prd_info

select * from bronze.crm_prd_info

 select prd_id,count(*)
 from bronze.crm_prd_info
 group by prd_id
 having count(*) > 1 or prd_id is null

 select prd_id,prd_key,
 replace(substring(prd_key,1,5),'-','_') as cat_id,
 substring(prd_key,7,len(prd_key)) as prd_key,
 prd_nm,
 prd_cost,
 prd_line,
 prd_start_dt,
 prd_end_dt
 from bronze.crm_prd_info
 where substring(prd_key,7,len(prd_key)) in (
select sls_prd_key
from bronze.crm_sales_details
 )

-- check for nulls or negative numbers
select prd_nm
from bronze.crm_prd_info
where prd_nm != trim(prd_nm)

select prd_cost
from bronze.crm_prd_info
where prd_cost < 0 or prd_cost is null

--check data standardization and consistency
select distinct prd_line
from silver.crm_prd_info

-- start date higher than end date
-- end date = start date of the next record -1

-- crm_sales_details

-- check for invalid dates
select sls_order_dt
from bronze.crm_sales_details
where sls_order_dt <= 0
-- if zeo make it null
--checking if length is 8 because its date fun

select nullif(sls_order_dt,0) 
from bronze.crm_sales_details
where sls_order_dt < 0 or len(sls_order_dt) != 8

-- check for invalid date orders
select *
from bronze.crm_sales_details
where sls_order_dt > sls_ship_dt or sls_order_dt > sls_due_dt


-- business rules
--sales = quantity * price, negative,zeros,nulls are not allowed!
select distinct sls_sales,sls_quantity,sls_price
from bronze.crm_sales_details
where sls_sales != sls_quantity * sls_price
or sls_sales is null or sls_quantity is null or sls_price is null
or sls_sales <= 0 or sls_quantity <= 0 or sls_price <= 

-- rules - if sales is neg,zero,null,derive it using quantity n price
-- if price is zero or null,calculate it using sales n quantity
-- if price is negative,convert it to a pos value


---trying tables

CALL bronze.load_bronze();
CALL silver.load_silver();


select * from bronze.crm_cust_info
select * from bronze.crm_prd_info
select * from bronze.crm_sales_details
select * from bronze.erp_cust_az12
select * from bronze.erp_loc_a101
select * from bronze.erp_px_cat_g1v2




select * from silver.crm_cust_info
select * from silver.crm_prd_info
select * from silver.crm_sales_details
select * from silver.erp_cust_az12
select * from silver.erp_loc_a101
select * from silver.erp_px_cat_g1v2


select * from gold.dim_customers;
select * from gold.dim_products
select * from gold.fact_sales

